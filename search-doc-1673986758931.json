[{"title":"Assets","type":0,"sectionRef":"#","url":"/api-reference/assets","content":"Assets üìÑÔ∏è Get Balance This endpoint returns the balance and available balance for a given asset.","keywords":""},{"title":"Getting Started","type":0,"sectionRef":"#","url":"/","content":"Getting Started Immersve is a multi-chain payment protocol and web3 / metaverse Mastercard¬Æ product. Powered by the tech and values of web3, Immersve enables its clients to deliver a decentralized payment experience to their users. This documentation is aimed at developers and technically-minded folks interested in integrating with or understanding the underlying mechanics of the Immersve solution. Included here are: Helpful guides demonstrate how to authenticate with the API and issue a virtual card.An API reference wherein you can view API request/response payloads and try interacting with the API from the browser.The Immersve Payment Protocol smart contract interface documentation.","keywords":""},{"title":"Authentication","type":0,"sectionRef":"#","url":"/api-reference/authentication","content":"Authentication üìÑÔ∏è Generate Challenge Generating the challenge is the first step in the process of getting the authentication token. üìÑÔ∏è Login The login endpoint returns the authentication token in exchange","keywords":""},{"title":"Currency","type":0,"sectionRef":"#","url":"/api-reference/currency","content":"Currency üìÑÔ∏è Currency List Get the list of currencies supported by Immersve. üìÑÔ∏è Currency Convert Convert a source currency to a target currency.","keywords":""},{"title":"Cards","type":0,"sectionRef":"#","url":"/api-reference/card","content":"Cards üìÑÔ∏è Order a Card Order a virtual card for the current user. üìÑÔ∏è Cancel a Card Cancel a card. üìÑÔ∏è Get a Card Token Generate a card token to enable the subsequent retrieval of the card's sensitive details including full PAN and CVV2. üìÑÔ∏è Get Prerequisite Transactions This endpoint returns the requisite blockchain transactions required to permit the creation of a new Immersve Card. It also indicates if everything is in order before instructing the client of any blockchain transactions. Insufficient KYC and AML status may trigger an error response. üìÑÔ∏è Get Secure Card Details The secure card details endpoint returns the sensitive card details when presented with a token obtained via the `generate card token` endpoint.","keywords":""},{"title":"Transactions","type":0,"sectionRef":"#","url":"/api-reference/transactions","content":"Transactions üìÑÔ∏è Get a Transaction This endpoint returns the details of a transaction by a given id.","keywords":""},{"title":"Authentication","type":0,"sectionRef":"#","url":"/guides/authentication","content":"Authentication Accounts are identified by way of blockchain addresses. Proof of ownership of an address is based upon a process of authentication by way of verification of EIP-4361 challenges signed by the private key underlying an address. Upon successful authentication, Immersve will issue an access token for subsequent use in interactions with the Immersve API. Subsequent requests for protected resources from the Immersve API may be authenticated by supplying the access token in the Authorization header. Login Flow‚Äã sequenceDiagram participant W as Web3 Wallet participant C as API Client participant I as Immersve C-&gt;&gt;+I: Generate challenge I--&gt;&gt;-C: Challenge C-&gt;&gt;W: Request to sign a message W--&gt;&gt;C: Signature C-&gt;&gt;+I: Send challenge + signature I--&gt;&gt;-C: Return access token note over C: Access token will be used for subsequent requests for protected resources from the Immersve API Generate a challenge. The response is an EIP-4361 message in plain text to be signed by the wallet. For example: app.immersve.com wants you to sign in with your Ethereum account: 0xA3058369d6A481B1ff08F62B352409c3D709De9b Sign in with Ethereum to the app. This request will not trigger a blockchain transaction or cost any gas fees. URI: https://app.immersve.com Version: 1 Chain ID: 1 Nonce: 2hFm7TDbZmerUgnrJ Issued At: 2022-08-11T22:29:48.244Z Invoke the wallet's message signing capability to get a signature for the given challenge message. The specific nature of the invocation of the message signing function is specific to the particular wallet in use. Submit the signed challenge along with the signature to get the access token. The access token should be used for subsequent requests for protected resources from the Immersve API by supplying it in the Authorization header.","keywords":""},{"title":"Immersve Payment Protocol","type":0,"sectionRef":"#","url":"/contracts/payment-protocol","content":"Immersve Payment Protocol Contract Module that allows users to deposit and lock funds in order to be able to fund one-time-use Immersve virtual cards. Extensions‚Äã For security reasons, the smart contract implements the following OpenZeppelin Contracts InitializableAccessControlPausableReentrancyGuard Proxy‚Äã The Smart Contract implements the OpenZeppelin TransparentUpgradeable proxy. Proxy features: Security: If any bugs are found, or potential security risks, the Smart Contract can be updated to resolve any potential issuesFeature Upgradeability: Any new features and bug fixes can be added. The Smart Contract will keep the same state, without the need of expensive migrationsStability: Clients interacting with the Smart Contract will always do so through the same proxy address. The proxy will know the current implementation address and will always keep the same state. More about upgradeable contracts here: https://blog.openzeppelin.com/the-state-of-smart-contract-upgrades/ graph LR Client -- Trx --&gt; Proxy[(Proxy)] Proxy -- &quot;getImplementation()&quot; --&gt; Proxy Proxy -- old --&gt; v1{{ContractImplV1}} Proxy -- &quot;delegate call&quot; --&gt; v2{{ContractImplV2}} Proxy URLs‚Äã Polygon (Mainnet): PENDINGPolygon Mumbai (Testnet): 0xa0947892376e8C4dA58Ce68Cdb100412AA126222 Functions‚Äã initialize(address _settlerRole, address payable _settlementAddress, address _usdcSmartContract, uint256 _defaultTimeoutBlocks, uint256 _safetyBlocks) external initializer‚Äã Initialize the Smart Contract with the required arguments _settlerRole (type address): The web3 address that will act with the SETTLER role._settlementAddress (type address payable): The web3 address were Locked funds will be sent once a payment is confirmed by Immersve_usdcSmartContract (type address): The current network address of the ERC-20 USDC Smart Contract_defaultTimeoutBlocks (type uint256): Number of blocks in the blockchain that an asset lock will last by default_safetyBlocks (type uint256): Number of blocks on top of the default timeout used to calculate if a Lock is usable or not. Because there might be a delay between a transaction confirmation and the actual use of Locked funds by Immersve, there has to be some safety threshold for Immersve to execute the settlement of funds. getVersion() external pure returns(string memory)‚Äã Get the current version implementation of the smart contract with a Version number stored in a Solidity Constant. This means that the constant is not saved into the Smart Contract store. pause() public onlyRole(PAUSER_ROLE)‚Äã Pauses the functionality of the Smart Contract. All the functions marked with the whenNotPaused modifier will reject the transaction once a pause is in effect. Only the PAUSER_ROLE will be able to call this function. unpause() public onlyRole(PAUSER_ROLE)‚Äã Unpauses the functionality of the Smart Contract. All the functions marked with the whenNotPaused modifier will accept the transaction normally. Only the PAUSER_ROLE will be able to call this function. setTimeoutBlocks(uint256 timeoutBlocks) public onlyRole(SETTLER_ROLE)‚Äã Set the default timeout for AssetLockedFund as described in Asset Locked Funds section. Only the SETTLER_ROLE will be able to call this function. timeoutBlocks (type uint256): Number of blocks for an Asset Lock to be considered expired setSafetyBlocks(uint256 timeoutBlocks) public onlyRole(SETTLER_ROLE)‚Äã Set the safety block threshold for AssetLockedFund as described in Asset Locked Funds section. Only the SETTLER_ROLE will be able to call this function. timeoutBlocks (type uint256): Number of blocks for an Asset Lock to be considered safe to settle deposit(uint256 usdcAmount) external whenNotPaused nonReentrant‚Äã CardHolders can deposit USDC funds into the Smart Contract using this function. The funds can either be locked or withdrawn by the consumer later. Locked funds cannot be withdrawn until the lock expires, or the user revokes the lock with an Immersve token. There is a pre-requisite for this function to work. Because USDC is an ERC-20 token, the consumer needs to approve (https://polygonscan.com/token/0x2791bca1f2de4661ed88a30c99a7a9449aa84174#writeProxyContract#F1 USDC funds to the Smart Contract public address usdcAmount (type uint256): USDC Amount to deposit in ethers format depositTo(uint256 usdcAmount, address sender) external whenNotPaused nonReentrant‚Äã CardHolders can deposit USDC funds for a specific address into the Smart Contract using this function. The funds can either be locked or withdrawn by the consumer later. Locked funds cannot be withdrawn until the lock expires, or the user revokes the lock with an Immersve token. There is a pre-requisite for this function to work. Because USDC is an ERC-20 token, the consumer needs to approve (https://polygonscan.com/token/0x2791bca1f2de4661ed88a30c99a7a9449aa84174#writeProxyContract#F1 USDC funds to the target sender address for the Smart Contract public address usdcAmount (type uint256): USDC Amount to deposit in ethers formataddress (type address): Deposit target address withdraw(uint256 usdcAmount) external whenNotPaused nonReentrant‚Äã CardHolders can withdraw USDC funds associated to their balance from the Smart Contract using this function. Locked funds cannot be withdrawn until the lock expires, or the user revokes the lock with an Immersve token. usdcAmount (type uint256): USDC Amount to withdraw in ethers format createLockedFund (uint256 usdcAmount) external whenNotPaused nonReentrant‚Äã CardHolders can put a Lock in place for deposited funds so Immersve can authorize the use of a credit card using those locked funds as collateral. The locked funds will be represented with a AssetLockedFund struct inside the Smart Contract. When created, a timeout will be put in place for this lock based on the default Timeout Blocks (see []) usdcAmount (type uint256): USDC Amount to lock in ethers format depositAndCreateLockedFund (uint256 usdcAmount) external whenNotPaused nonReentrant‚Äã Similar to deposit but combined with createLockedFund. This function is doing both the deposit and the lock at the same time to save gas fees. usdcAmount (type uint256): USDC Amount to deposit in ethers format depositAndCreateLockedFundFor (uint256 usdcAmount, address sender) external whenNotPaused nonReentrant‚Äã Similar to depositAndCreateLockedFund but the target address is specified as an argument instead of using msg.sender usdcAmount (type uint256): USDC Amount to deposit in ethers format checkLockedFundPayment (address sender, uint256 price, uint256 lockedFundId) external view whenNotPaused returns(uint256)‚Äã Used by Immersve to check that the locked funds of an Immersve Card payment is currently valid. This function will check that the specified address has enough locked funds for the specified lockedFundId and will return the number of blocks that the lock is still valid for. sender (type address): CardHolder Address doing a payment requiring locked funds with Immersveprice (type uint256): USDC Amount to settle in ethers formatlockedFundId (type uint256): Matching Locked Fund Id (which is linked to a Card) to settle payment being done with an Immersve Credit Card confirmLockedFundPayment (address sender, uint256 price, uint256 lockedFundId) external whenNotPaused nonReentrant onlyRole(SETTLER_ROLE)‚Äã Used by Immersve to confirm the settlement of an Immersve Card payment. This function will check that the specified address has enough locked funds for the specified lockedFundId and will transfer the settlement amount (price) to the settlement address, specified in the initialize function. It can only be called by the SETTLER role sender (type address): CardHolder Address doing a payment requiring locked funds with Immersveprice (type uint256): USDC Amount to settle in ethers formatlockedFundId (type uint256): Matching Locked Fund Id (which is linked to a Card) to settle payment being done with an Immersve Credit Card getAvailableLockedFundsBalance (address sender)‚Äã Get Available Locked funds for the specified address sender (type address): CardHolder Address that already did a funds lock getBalance()‚Äã Get the available USDC balance of the msg.sender deposited in the Smart Contract. Balance is not the necessarily the same as locked funds as the former are short lived. getSenderBalance (address sender)‚Äã Get the available USDC balance of the specified sender argument, deposited in the Smart Contract. Balance is not the necessarily the same as locked funds as the former are short lived. sender (type address): CardHolder Address getLockedFunds()‚Äã Get the AssetLockedFund objects of the msg.sender getSenderLockedFunds (address sender) onlyRole(SETTLER_ROLE)‚Äã Get the AssetLockedFund objects of the specified sender argument sender (type address): CardHolder Address that already locked funds at least once revokeLockedFundMultiSig (uint256 lockedFundId, uint256 nonce, bytes memory signature) external whenNotPaused nonReentrant‚Äã CardHolders will be able to revoke a fund lock using an Immersve signature. Immersve will first check if the funds is being used for a payment on Immersve backend. If the funds are free to release, Immersve will sign a message with a nonce only valid for a lockedFundId and the funds will be put back into the CardHolder balance lockedFundId (type uint256): Id of the AssetLockedFund to be releasednonce (type uint256): Nonce provided by Immersve API and matches the signaturesignature (type memory): String signature provided by Immersve API created with a nonce to avoid replay calls revokeLockedFund (address sender, uint256 lockedFundId) external whenNotPaused nonReentrant onlyRole(SETTLER_ROLE)‚Äã Function used by Immersve Backend (only SETTLER role can call this function) to revoke an unexpired lock. This could be done if Immersve detect illegal or malicious activity related to the sender and prefers to revoke locked fund ids sender (type address): CardHolder Address that already locked funds with the Smart ContractlockedFundId (type uint256): Id of the AssetLockedFund to be released Immersve Card E-Commerce Payment Happy Path‚Äã Card Holder locks USDC funds with Immersve Smart ContractCard Holder receives a valid Credit Card to be used for E-Commerce transaction from ImmersveCard Holder uses the Immersve Card to pay for goods purchased on an E-Commerce platformImmersve authorizes the payment with Credit Card network once the locked funds are confirmedPurchase is confirmed by Immersve and E-Commerce merchant sequenceDiagram participant H as Card Holder participant W as Web-3 Wallet participant I as Immersve Backend participant S as Smart Contract participant U as USDC Smart Contract participant E as E-Commerce website participant M as E-Commerce Merchant H-&gt;&gt;I: Create card pre-request I--&gt;&gt;H: Web3 Transaction Details H-&gt;&gt;W: Submit Transactions W-&gt;&gt;U: Approve Card Total Authorized Amount in USDC W-&gt;&gt;S: Deposit and Lock USDC funds S-&gt;&gt;U: Transfer approved amount from Card Holder wallet to Immersve Smart Contract S--&gt;&gt;S: Add approved amount to Card Holder address balance S--&gt;&gt;S: Create AssetLockedFund to temporarily lock Card Holder funds to be used by Immersve Card S--&gt;&gt;W: Transaction Hash W--&gt;&gt;H: Transaction Hash H-&gt;&gt;I: Card Create Request I-&gt;&gt;S: Check enough funds for Card creation S--&gt;&gt;I: Locked Funds confirmed I--&gt;&gt;H: Card created H-&gt;&gt;E: Use Immersve Card to pay for goods online E--&gt;&gt;M: Validate Credit Card payment M-&gt;&gt;I: Merchant request payment authorization through Credit Card network I-&gt;&gt;S: Check locked funds and settle payment amount S-&gt;&gt;S: Settle payment funds I-&gt;&gt;M: Authorize payment","keywords":""},{"title":"Card Lifecycle","type":0,"sectionRef":"#","url":"/guides/card-lifecycle","content":"Card Lifecycle Card States‚Äã Single-use virtual cards are activated and ready to use by default. When the card is either used to make a purchase or cancelled by the user it will transition to the cancelled state. stateDiagram-v2 [*]--&gt;¬†Active: create Active--&gt;Cancelled : cancel_card Active--&gt;Cancelled : once_used Cancelled --&gt;¬†[*] State Transitions‚Äã Order a card‚Äã A card begins life when you call the order a card operation to request Immersve to generate a card. Cancel a card‚Äã Should a cardholder change their mind prior to presenting the card to a merchant, you can cancel the card by calling the cancel a card operation.","keywords":""},{"title":"Issue a Virtual Card","type":0,"sectionRef":"#","url":"/guides/issue-a-virtual-card","content":"Issue a Virtual Card A virtual card is a payment card that exists only in digital form. As such, virtual cards are most suitable for online e-commerce purchases as opposed to in-store purchases at brick-and-mortar merchants. Immersve treat virtual cards as being logically time-bound and ephemeral. Beginning at the time of issuance of a virtual card, it has a finite useable lifespan which is often represeted within the UI of the issuing client application as a stopwatch-type timer. This model presents certain benefits over a traditional persistent payment card model (be they virtual, tokenized or physical) in that the potential for card fraud is dramatically reduced. The use of web3-native authentication mechanisms within the context of card issuance mean that the same level of protection to a user's funds in self-custodial wallets is applied to their activities as a cardholder. Prior to being permitted to order a card a user must first have successfuly authenticated and locked digital assets within the smart contract via digital asset transfer and smart contract invocations as instructed by the get prerequisite tranasactions operation. Authentication‚Äã The authentication processes is described in the authentication guide. As the user account is anchored by control of the private key, there is no distinct prior explicit registration or signup process needed before authenticating. Currency Conversion‚Äã A user will more often than not be quoted a price for a purchase by a merchant in a fiat currency. In order to determine the sufficient amount of digital assets to fund a card and be made available for the purchase, you will retrieve the amount from the currency conversion API endpoint. Lock Funds‚Äã In order to ensure that funds are sufficiently locked within the smart contract such that Immersve are in a position to approve an authorization request received via the card scheme network you will need to have firstly locked sufficient digital assets within the smart contract via digital asset transfer and smart contract invocations as instructed by the get prerequisite tranasactions operation. The necessary blockchain transactions are contained within the requiredTransactions collection returned. If the user has not transacted using the solution before then the the get prerequisite transactions response will typically call for and erc20_approval in favour of the smart contract followed by a depositAndCreateLockedFund invocation of the smart contract. If multiple transactions are present then they should be carried out in the order in which they are presented. The client application is to parse and formulate the raw blockchain transaction message such that it is presented to the user within the web3 wallet and signed and sent to the relevant blockchain. Order a Card‚Äã With the funds locked in the smart contract, it's now time to order a card. Call the order a card operation to request Immersve to generate a card. The returned card data returned in response to a order a card request includes only truncated or masked sensitive data. Single-use virtual cards are activated and ready to use by default. Issue a Card‚Äã Having created an virtual card via the order a card operation, you are in a position to be able to obtain the sensitive card details to be presented to the cardholder. There are two steps in this process; firstly, obtaining a token for transmission to the client application to which the card details are to be provided (i.e. the application that will display the card data to the cardholder) and;secondly, the exchange, by that client application, of the token for the card data. note It is not recommended that the card token is supplied to any application other than one that resides within the cardholder environment (i.e. their mobile application or web application running in their browser) unless that system is sufficiently compliant with PCI-DSS requirements and is audited as such. Get a Card Token‚Äã Generate a single-use card token using the get a card token operation. The token is typically then transmitted to the cardholder's environment (i.e. web application or mobile application running in their web browser) to complete the final step completing the card issuance. Get Card Details‚Äã To obtain the full PAN and CVV2 for display to the cardholder your client-side application should exchange the token for the sensitive card data via the get secure card details operation. Virtual Card Issuance Sequence Diagram‚Äã sequenceDiagram participant U as User participant C as API Client participant I as Immersve participant W as Wallet participant B as Blockchain note over U: Authentication as per authentication guide U-&gt;&gt;C: Input desired fiat card funding amount C-&gt;&gt;+I: Currency convert I--&gt;&gt;C: convertedAmount C-&gt;&gt;I: Get prerequisite transactions I--&gt;&gt;C: requiredTransactions collection loop For each required transaction C-&gt;&gt;C: Construct raw transaction message C-&gt;&gt;W: Transmit raw transaction to wallet U-&gt;&gt;W: Confirm / authorize transaction W-&gt;&gt;B: Transmit transaction end C-&gt;&gt;+I: Order card I--&gt;&gt;C: Non-sensitive card data C-&gt;&gt;+I: Get card token I--&gt;&gt;C: Card token C-&gt;&gt;I: Request sensitive card data I--&gt;&gt;C: Return sensitive card data C--&gt;&gt;U: Display sensitve card data","keywords":""}]